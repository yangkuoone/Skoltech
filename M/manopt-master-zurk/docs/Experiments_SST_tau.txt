Эксперимент:
	1. N - количество вершин, чтобы считалось быстро, но граф был нормального размера 100-500 вершин.
	2. q - вероятность появления ребра между кластерами
	   например q = [0.01, 0.05, 0.1, 0.2]. Для каждого q отдельный график
	3. Перебираем p = [q, q*1.5, q*2, q*2.5, q*3, ...., 0.5] (например)
	4. Генерируем граф
	5. Перебираем tau в логичном диапазоне (это надо продумать), возможно в лог-шкале. Может tau = [1e-4,... , 1e+4].
	6. Запускаем метод (который надо оформить и положить в файл sample_splitting_technique.py (на вход методу подается матрица смежности и доп.парамертры))
	7. Запоминаем NMI и количество сообществ.
	8. Данные эксперимента сохранять в файл, чтобы не потерялись и не пришлось пересчитывать (я обычно сохраняю через pandas в csv)

Задачи:
	1. Для каждого q нарисовать 2 heapmap-графика:
		1. NMI цветом в зависимости от tau и p
		2. Количество выделенных методом сообществ цветом в зависимости от tau и p
	2. Сравнить значения с выбором tau из GeoNMF. Проверить "оптимальность" этого выбора.
	3. Сделать выводы, оформить результаты.

Несколько замечаний:
	1. От намеченного плана можно при необходимости отклоняться, главное это выводы. Необходимо понять как работать с параметром tau и убедиться, что метод работает адекватно.
	2. Пункт 6 Эксперимента можно повторять несколько раз и усреднять результаты, чтобы получить более гладкие графики.
	3. Для ускорения советую использовать Pool (from multiprocessing import Pool). Так можно легко распаралелить код на несколько ядер. Кажется ipyton на этот модуль ругается и не дружит с ним, и я уносил паралельный код в отдельный файл и оттуда его запускал.
	4. Если долгие расчеты я могу их поставить на ночь на свою машину.